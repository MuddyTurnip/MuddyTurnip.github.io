¬import gl from "../../../_shared/glossaryLinks"
¬import ghl from "../../../_shared/grasshopperLinks"


#### How to:

As per usual, we're going to start this session by modelling our {{gl.cell-link}}. This means picking our {{gl.manipulator-link}}, **Attaching** a {{gl.end-effector-link}}, and importing our {{gl.positioner-link}}. This is where things start deviating slightly from our [synchronization](#35-synchronize-motion) tutorial. In this instance we actually want to mount one of our {{gl.mechanisms-link}} on another. The HAL Robotics Framework doesn't really make a distinction between {{gl.mechanism-link}} types e.g. {{gl.positioner-link}}, {{gl.manipulator-link}} or {{gl.end-effector-link}}, so we can use the exact same strategy as **Attaching** our {{gl.end-effector-link}} to the {{gl.manipulator-link}}. We'll use the **Attach** component with the **Track** as the _Parent_ and the {{gl.manipulator-link}} + {{gl.end-effector-link}} combination as the _Child_. Ensure that _IsEndEffector_ is left as `true` because our _Child_ contains our desired [End Effector]{{gl.end-effector-link-D}}. We can use the _Location_ and _InWorld_ parameters to adjust the position and orientation of the {{gl.manipulator-link}} on the **Track**. This will create a single {{gl.mechanism-link}} that we can program as we would any other {{gl.mechanism-link}}, however, this monolithic approach doesn't give us as much freedom as treating this like a multi-{{gl.mechanism-link}} setup does. N.B. If you do use the single {{gl.mechanism-link}} approach, ensure any {{gl.joint-space-lc-link}} {{gl.targets-link}} are a) in SI units for the relevant joints, and b) are in the right order i.e. with the **Track** first in this case (_Parent_ joints followed by _Child_ joints). To return to a multi-{{gl.mechanism-link}} scenario we can use the **Disassemble** component from **HAL Robotics** -\> **Cell**. This will split our {{gl.mechanism-link}} into its constituent parts including its _SubMechanisms_, that is to say, the {{gl.mechanisms-link}} which make it up. We can now treat the _SubMechanisms_ as we did our {{gl.mechanisms-link}} in [previous](#35-synchronize-motion) [tutorials](#36-coupled-motion-and-resolving-targets).

There are a few subtleties to programming a **Track** so let's walk through an example. Let's start by preparing a simple curve following {{gl.procedure-link}} for the {{gl.manipulator-link}} as we did in the [Getting Started tutorial]{{ghl.grasshopper-getting-started-link-D}}. Ensure the **Track** is actually required by making this curve longer than the [Robot's]{{gl.manipulator-link-D}} reach. We can then program the **Track** using {{gl.targets-link}} as we do for any other {{gl.mechanism-link}} for maximum control, or using the **Target Resolvers** seen in a [previous tutorial](#36-coupled-motion-and-resolving-targets) for a quick but effective approach. For a **Track** the **Offset** **Target Resolver** overload is of particular use. The default version of this component asks simply for an _Offset_ distance which is the distance the **Track's** {{gl.endpoint-link}} (and by extension the [Robot's]{{gl.manipulator-link-D}} base) should be kept from the [Robot's]{{gl.manipulator-link-D}} {{gl.target-link}}. Setting the _Offset_ to `0` or any value less than the distance between the **Track's** {{gl.endpoint-link}} and {{gl.target-link}} will cause the **Track** to get as close to the {{gl.target-link}} as possible. To create a full {{gl.procedure-link}} for the **Track** we need to set some **Sync Settings** for the [Robot's]{{gl.manipulator-link-D}} {{gl.motion-action-move-link}} and can then use the **Synchronize** utility overload of the **Move** component to synchronize our **Target Resolver** with the full {{gl.manipulator-link}} {{gl.procedure-link}} (see the [Synchronize Motion tutorial]{{ghl.grasshopper-synchronize-motion-link-D}} for a refresher on how to do this). As one {{gl.mechanism-link}} is moving another, you will also need to ensure that the **Kinematic Settings** are in place for this setup, with the **Track** as the _Primary_ and {{gl.manipulator-link}} as a _Secondary_, in both the [Robot's]{{gl.manipulator-link-D}} {{gl.motion-action-move-link}} and the **Track's** (see the [Coupled Motion and Resolving Targets tutorial]{{ghl.grasshopper-coupled-motion-link-D}} as a reminder if needed). With this in place we are in a position to **Solve** and **Execute** and we should see both {{gl.mechanisms-link}} moving as we expect.

Although [exporting]{{gl.export-link-D}} is covered in a later [tutorial]{{ghl.grasshopper-export-procedure-link-D}}, there are a couple of things that need to be setup for external axes that are worth looking at here if your {{gl.positioner-link}} is an external axis and programmed within the same exported {{gl.procedure-link}} as your {{gl.manipulator-link}}.
1. You'll need to setup your {{gl.joint-mapping-link}}.  When you created or loaded your {{gl.positioner-link}} you will likely have glossed over the _Mapping(s)_ input. These values are 0-based indices of any external [axis]{{gl.joint-link-D}} that needs to be exported. In our example above, we have 6 axes in our {{gl.manipulator-link}} and our {{gl.positioner-link}} comes after that. We can therefore assign it an index of `6` (0-based, so 7th when exported) or higher depending on the exact configuration of our real {{gl.cell-link}}.
2. You'll need to set your {{gl.positioner-link}} {{gl.procedure-link}} as a child of your {{gl.manipulator-link}} {{gl.procedure-link}}. This can be done in the {{gl.controller-link}} configuration, accessible by double-clicking on your {{gl.controller-link}} component. On the right-hand side of this window you should see both of the {{gl.procedures-link}} listed. Drag the {{gl.positioner-link}} {{gl.procedure-link}} onto the main {{gl.procedure-link}} to make it a child. As you're doing this, ensure that the _Task Alias_ of your main {{gl.procedure-link}} matches the target **Task** on your real {{gl.controller-link}}.

---
