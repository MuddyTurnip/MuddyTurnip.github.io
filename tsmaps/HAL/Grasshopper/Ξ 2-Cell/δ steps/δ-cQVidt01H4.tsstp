Â¬import gl from "../../../_shared/glossaryLinks"


#### How to:

In our previous tutorial we used a theoretical plane as our [Tool Centre Point (TCP)]{{gl.endpoint-link-D}}. To ensure our simulation matches the real world as closely as possible we're going to swap this out for calibrated data. In this tutorial I am using a 3D printed {{gl.end-effector-link}} which is mounted on an ABB arm. I have calibrated the {{gl.end-effector-link}} using the real {{gl.manipulator-link}} and simply copied and pasted that information into my Grasshopper document. As I'm using an ABB {{gl.manipulator-link}} the code imported is in RAPID, ABB's {{gl.manipulator-link}} programming language. Additionally, I have extracted the information I need, in particular the X, Y and Z co-ordinates of the {{gl.endpoint-tcp-link}} and its orientation as a quaternion because that's the formalism used by ABB. Converting between different frame formalisms can be complicated but we've included the **Frame** component to make it a breeze. You'll find **Frame** under the **HAL Robotics** tab, **Utilities** panel. By default, the **Frame** component comes in as Euler frame. By right-clicking on the component we can see that there are a variety of formalisms on offer to suit importing data from any {{gl.manipulator-link}} manufacturer. In this instance we want to select quaternion frame. This first overload of the component asks for the _Origin_ and 4 quaternion components. As we have the co-ordinates of the {{gl.endpoint-tcp-link}} as individual values, we can switch to the alternative overload of quaternion frame to get _X_, _Y_ and _Z_ as individual inputs. We need to ensure that the units are correct. ABB RAPID positions are in millimeters so as long as that's what's on our inputs we're ok there. We can now hook all of the imported data into the **Frame**. Once that's done, we can replace the _ToolFrame_ we had previously, the simulation will re-{{gl.solving-link}} and we can see that the {{gl.endpoint-tcp-link}} is slightly offset from the CAD data, as we would expect from a 3D printed tool with moving parts. When we now **Simulate**, we can see that our calibrated {{gl.endpoint-tcp-link}} is hitting all of our {{gl.targets-link}} not the CAD tool tip.

---
